from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
import requests
import io
import urllib.parse
import os
import hashlib
import logging

# –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
CORS(app)

HF_API_KEY = os.getenv('HF_API_KEY')

@app.before_request
def log_request_info():
    """–õ–æ–≥–∏—Ä—É–µ–º –≤—Å–µ –≤—Ö–æ–¥—è—â–∏–µ –∑–∞–ø—Ä–æ—Å—ã"""
    logger.info(f"üì• –í—Ö–æ–¥—è—â–∏–π –∑–∞–ø—Ä–æ—Å: {request.method} {request.path}")

def translate_with_deepseek(text):
    """–ü–µ—Ä–µ–≤–æ–¥ —á–µ—Ä–µ–∑ DeepSeek API"""
    logger.info(f"üß† –ü–µ—Ä–µ–≤–æ–¥: '{text}'")
    try:
        response = requests.post(
            'https://api.deepseek.com/v1/chat/completions',
            headers={'Content-Type': 'application/json'},
            json={
                'model': 'deepseek-chat',
                'messages': [
                    {
                        'role': 'system', 
                        'content': 'You are a professional translator. Translate Russian to English accurately. Return only the translation without any additional text.'
                    },
                    {
                        'role': 'user', 
                        'content': f'Translate this to English: "{text}"'
                    }
                ],
                'temperature': 0.1,
                'max_tokens': 1000
            },
            timeout=30
        )
        
        if response.status_code == 200:
            result = response.json()
            translation = result['choices'][0]['message']['content'].strip()
            translation = translation.strip('"')
            logger.info(f"‚úÖ –ü–µ—Ä–µ–≤–µ–ª: '{translation}'")
            return translation
        else:
            logger.error(f"‚ùå DeepSeek —Å—Ç–∞—Ç—É—Å: {response.status_code}")
            return None
            
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞: {e}")
        return None

def translate_text(text):
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–≤–æ–¥–∞"""
    if not any(char.lower() in '–∞–±–≤–≥–¥–µ—ë–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è' for char in text):
        return text
    
    translation = translate_with_deepseek(text)
    if translation and translation != text:
        return translation
    else:
        logger.warning("‚ö†Ô∏è –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç")
        return text

def describe_image_for_prompt(image_file):
    """–ü—Ä–æ—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
    if image_file and image_file.filename:
        filename_lower = image_file.filename.lower()
        if any(word in filename_lower for word in ['portrait', 'face', 'person']):
            return "a portrait photo"
        elif any(word in filename_lower for word in ['landscape', 'nature', 'mountain']):
            return "a landscape photo" 
        elif any(word in filename_lower for word in ['city', 'urban', 'building']):
            return "an urban cityscape"
        elif any(word in filename_lower for word in ['cat', 'dog', 'animal']):
            return "an animal photo"
        else:
            return "an uploaded image"
    return "an uploaded image"

def create_consistent_seed(prompt, model_name):
    """–°–æ–∑–¥–∞–µ—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π seed –¥–ª—è –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –ø—Ä–æ–º–ø—Ç–æ–≤"""
    # –•—ç—à–∏—Ä—É–µ–º –ø—Ä–æ–º–ø—Ç + –º–æ–¥–µ–ª—å —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–π seed
    seed_string = f"{prompt}_{model_name}"
    seed_hash = hashlib.md5(seed_string.encode()).hexdigest()
    # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ 8 —Å–∏–º–≤–æ–ª–æ–≤ —Ö—ç—à–∞ –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —á–∏—Å–ª–æ
    return int(seed_hash[:8], 16) % 1000000

def create_smart_prompt(base_prompt, image_description=None, edit_mode=False):
    """–°–æ–∑–¥–∞–µ—Ç —É–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏"""
    if edit_mode and image_description:
        return f"{base_prompt} - edit and modify {image_description} while preserving original composition and style"
    elif image_description:
        return f"{base_prompt} - based on {image_description} with similar colors and style"
    else:
        return base_prompt

@app.route('/generate', methods=['POST'])
def generate_image_route():
    try:
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∑–∞–ø—Ä–æ—Å–∞
        if request.content_type and request.content_type.startswith('multipart/form-data'):
            prompt = request.form.get('prompt', '')
            model_name = request.form.get('model', 'nanobanano')
            image_file = request.files.get('image')
            edit_mode = request.form.get('edit_mode') == 'true'
        else:
            data = request.get_json() or {}
            prompt = data.get('prompt', '')
            model_name = data.get('model', 'nanobanano')
            image_file = None
            edit_mode = data.get('edit_mode', False)
        
        if not prompt:
            return jsonify({"error": "–ü—Ä–æ–º–ø—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º"}), 400
        
        logger.info(f"üé® –ù–∞—á–∏–Ω–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é: '{prompt}'")
        logger.info(f"üîß –ú–æ–¥–µ–ª—å: {model_name}")
        logger.info(f"üìù –†–µ–∂–∏–º: {'—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ' if edit_mode else '—Å–æ–∑–¥–∞–Ω–∏–µ'}")
        
        # –û–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –µ—Å–ª–∏ –µ—Å—Ç—å
        image_description = ""
        if image_file and image_file.filename:
            image_description = describe_image_for_prompt(image_file)
            logger.info(f"üñºÔ∏è –û–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {image_description}")
        
        # –°–æ–∑–¥–∞–µ–º —É–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç
        smart_prompt = create_smart_prompt(prompt, image_description, edit_mode)
        logger.info(f"üí° –£–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç: '{smart_prompt}'")
        
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–≤–æ–¥
        translated_prompt = translate_text(smart_prompt)
        logger.info(f"üåê –ü–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç: '{translated_prompt}'")
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        encoded_prompt = urllib.parse.quote(translated_prompt)
        
        # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π seed, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–π
        seed = create_consistent_seed(translated_prompt, model_name)
        logger.info(f"üå± Seed: {seed} (–æ–¥–∏–Ω–∞–∫–æ–≤—ã–π –¥–ª—è –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –ø—Ä–æ–º–ø—Ç–æ–≤)")
        
        if model_name in ["nanobanano", "pollinations", "flux", "dalle", "stable-diffusion", "midjourney"]:
            # –ë–ï–ó seed –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ - –±—É–¥–µ—Ç –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            url = f"https://image.pollinations.ai/prompt/{encoded_prompt}?model={model_name}&width=512&height=512"
            logger.info(f"üîó Pollinations URL (–±–µ–∑ seed)")
            response = requests.get(url, timeout=60)
        else:
            url = f"https://api-inference.huggingface.co/models/{model_name}"
            headers = {"Authorization": f"Bearer {HF_API_KEY}"} if HF_API_KEY else {}
            logger.info(f"üîó Hugging Face URL")
            response = requests.post(url, headers=headers, json={
                "inputs": translated_prompt,
                "options": {"wait_for_model": True}
            }, timeout=60)
        
        logger.info(f"üì° –°—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞: {response.status_code}")
        
        if response.status_code == 200:
            logger.info("‚úÖ –£–°–ü–ï–•: –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ!")
            return send_file(
                io.BytesIO(response.content),
                mimetype='image/png'
            )
        else:
            error_msg = response.text[:200] if response.text else "Unknown error"
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ API: {error_msg}")
            return jsonify({"error": f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {error_msg}"}), 500
        
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {str(e)}")
        return jsonify({"error": f"–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}"}), 500

@app.route('/health', methods=['GET'])
def health_check():
    return jsonify({"status": "OK", "message": "–°–µ—Ä–≤–µ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç"})

@app.route('/translate-test', methods=['POST'])
def translate_test():
    """–¢–µ—Å—Ç –ø–µ—Ä–µ–≤–æ–¥–∞"""
    try:
        data = request.get_json() or {}
        text = data.get('text', '')
        
        if not text:
            return jsonify({"error": "–¢–µ–∫—Å—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º"}), 400
        
        logger.info(f"üß™ –¢–µ—Å—Ç –ø–µ—Ä–µ–≤–æ–¥–∞: '{text}'")
        
        is_russian = any(char.lower() in '–∞–±–≤–≥–¥–µ—ë–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è' for char in text)
        
        if is_russian:
            translation = translate_with_deepseek(text)
            return jsonify({
                "original": text,
                "translated": translation,
                "is_russian": True,
                "translation_worked": translation is not None
            })
        else:
            return jsonify({
                "original": text,
                "translated": text,
                "is_russian": False,
                "message": "–¢–µ–∫—Å—Ç —É–∂–µ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º"
            })
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    logger.info("üöÄ –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞...")
    app.run(host='0.0.0.0', port=5000, debug=False)
